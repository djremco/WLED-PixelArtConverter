<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>WLED Pixel Art Converter v2.0</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #111;
      color: #ddd;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 900px;
      margin: auto;
      text-align: center;
    }
    h1 {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
    }
    td {
      padding: 6px;
      vertical-align: middle;
    }
    input, select, button {
      background-color: #222;
      border: 1px solid #333;
      color: #ddd;
      font-size: 14px;
      border-radius: 6px;
      padding: 4px 6px;
    }
    #drop-zone {
      border: 2px dashed #777;
      color: #888;
      padding: 20px;
      margin: 15px 0;
      cursor: pointer;
    }
    textarea {
      width: 100%;
      height: 250px;
      background: #222;
      color: #ddd;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 8px;
      font-family: monospace;
      margin-top: 10px;
    }
    #pixelCanvas {
      width: 100%;
      background: #000;
      border: 1px solid #333;
      margin-top: 10px;
    }
    .button-row {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .button-row button {flex:1}
  </style>
</head>
<body>
<div class="container">
  <h1>ðŸ§© WLED Pixel Art Converterâ€¯v2.0</h1>
  <h2>Originele Werkstromâ€¯1.0.8â€¯functiesâ€¯+â€¯verticalâ€¯serpentine</h2>
  <table id="fieldTable">
    <tr>
      <td><label for="ledSetupSelector">LEDâ€¯Setup:</label></td>
      <td>
        <select id="ledSetupSelector">
          <option value="matrix" selected>2Dâ€¯Matrixâ€¯(horizontal)</option>
          <option value="r2l">Serpentineâ€¯â€“â€¯firstâ€¯rowâ€¯â†’â€¯left</option>
          <option value="l2r">Serpentineâ€¯â€“â€¯firstâ€¯rowâ€¯â†’â€¯right</option>
          <option value="matrix_v_serp">Verticalâ€¯serpentineâ€¯(topâ€‘bottomâ€¯â†‘â†“)</option>
        </select>
      </td>
    </tr>
    <tr>
      <td><label for="outputMode">Outputâ€¯format:</label></td>
      <td>
        <select id="outputMode">
          <option value="wled" selected>WLEDâ€¯JSON</option>
          <option value="curl">CURL</option>
          <option value="ha">Homeâ€¯Assistantâ€¯YAML</option>
        </select>
      </td>
    </tr>
    <tr>
      <td><label for="colorFormat">Colorâ€¯format:</label></td>
      <td>
        <select id="colorFormat">
          <option value="hex" selected>HEXâ€¯("RRGGBB")</option>
          <option value="dec">DECâ€¯(R,G,B)</option>
        </select>
      </td>
    </tr>
    <tr>
      <td><label for="addressingMode">Addressingâ€¯mode:</label></td>
      <td>
        <select id="addressingMode">
          <option value="single">Single</option>
          <option value="range">Rangeâ€¯(start,end,color)</option>
          <option value="hybrid" selected>Hybridâ€¯(color,start,end,color)</option>
        </select>
        <button onclick="addressingExample()" style="margin-left:8px">example</button>
      </td>
    </tr>
    <tr>
      <td><label for="brightness">Brightness:</label></td>
      <td><input type="range" id="brightness" min="1" max="255" value="128"></td>
    </tr>
    <tr>
      <td><label for="colorLimit">Maxâ€¯colorsâ€¯/â€¯JSON:</label></td>
      <td><input type="number" id="colorLimit" min="1" max="512" value="256"></td>
    </tr>
    <tr>
      <td><label for="sizeX">Width:</label></td>
      <td><input type="number" id="sizeX" value="23"></td>
    </tr>
    <tr>
      <td><label for="sizeY">Height:</label></td>
      <td><input type="number" id="sizeY" value="26"></td>
    </tr>
    <tr>
      <td><label for="deviceIP">Deviceâ€¯IP:</label></td>
      <td><input type="text" id="deviceIP" value="192.168.0.100"></td>
    </tr>
    <tr>
      <td><label for="segmentID">Segmentâ€¯ID:</label></td>
      <td><input type="number" id="segmentID" value="0"></td>
    </tr>
  </table>

  <div id="drop-zone">Dropâ€¯imageâ€¯hereâ€¯orâ€¯clickâ€¯toâ€¯selectâ€¯aâ€¯file</div>
  <input type="file" id="file-picker" style="display:none">

  <canvas id="pixelCanvas"></canvas>
  <textarea id="JSONled" readonly></textarea>

  <div class="button-row">
    <button id="copyJSON">Copyâ€¯Output</button>
    <button id="downloadJSON">Downloadâ€¯Output</button>
  </div>

  <p style="color:#666;margin-top:10px">
    v2.0 â€“ Complete releaseâ€¯(2025â€‘10)
  </p>
</div>

<!-- === JavaScript Section === -->
<script>
// -------- Helper setup ----------
const d=document;
function gId(id){return d.getElementById(id);}
const canvas=gId('pixelCanvas');
const ctx=canvas.getContext('2d',{willReadFrequently:true});
const dropZone=gId('drop-zone');
const filePicker=gId('file-picker');
const output=gId('JSONled');

// Upload events
dropZone.addEventListener('click',()=>filePicker.click());
filePicker.addEventListener('change',e=>loadImage(e.target.files[0]));
dropZone.addEventListener('dragover',e=>e.preventDefault());
dropZone.addEventListener('drop',e=>{e.preventDefault();loadImage(e.dataTransfer.files[0]);});

function loadImage(file){
  const r=new FileReader();
  r.onload=()=>{
    const img=new Image();
    img.onload=()=>getPixelRGBValues(img);
    img.src=r.result;
  };
  r.readAsDataURL(file);
}

gId('copyJSON').addEventListener('click',()=>navigator.clipboard.writeText(output.value));
gId('downloadJSON').addEventListener('click',()=>{
  const blob=new Blob([output.value],{type:'application/json'});
  const a=d.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='wled_pixel_data.json';
  a.click();
});

// -------- Exportfuncties ----------
function exportPixels(pixels,set){
  const {brightness,segment,colorFormat,outputMode,device,colorLimit}=set;
  const col=(h)=>colorFormat==="dec"
    ? [parseInt(h.substr(0,2),16),parseInt(h.substr(2,2),16),parseInt(h.substr(4,2),16)]
    : h;

  const arr=[];
  for(let i=0;i<pixels.length;i+=colorLimit){
    const chunk=pixels.slice(i,i+colorLimit);
    const seg={on:true,bri:brightness,seg:{id:segment,i:chunk.map(p=>colorFormat==="dec"?col(p.color):`"${p.color}"`)}};
    arr.push(JSON.stringify(seg));
  }

  if(outputMode==="wled") return arr.join("\n");
  if(outputMode==="curl") return arr.map(j=>`curl -X POST "http://${device}/json/state" -H "Content-Type: application/json" -d '${j}'`).join("\n");
  if(outputMode==="ha") return `# Home Assistant YAML\n- platform: command_line\n  switches:\n    pixel_display:\n      friendly_name: Pixel Display\n      command_on: >\n        ${arr.map(j=>`curl -X POST "http://${device}/json/state" -H "Content-Type: application/json" -d '${j}'`).join(" && ")}\n      command_off: >\n        curl -X POST "http://${device}/json/state" -H "Content-Type: application/json" -d '{"on":false}'`;
  return "";
}

// -------- Hoofdfunctie ----------
function getPixelRGBValues(img){
  const w=parseInt(gId('sizeX').value);
  const h=parseInt(gId('sizeY').value);
  const layout=gId('ledSetupSelector').value;
  const bri=parseInt(gId('brightness').value);
  const outputMode=gId('outputMode').value;
  const colorFormat=gId('colorFormat').value;
  const addressing=gId('addressingMode').value;
  const deviceIP=gId('deviceIP').value;
  const segment=parseInt(gId('segmentID').value);
  const colorLimit=parseInt(gId('colorLimit').value);

  canvas.width=w;canvas.height=h;
  ctx.drawImage(img,0,0,w,h);
  const data=ctx.getImageData(0,0,w,h).data;
  const pixels=[];

  for(let i=0;i<data.length;i+=4){
    const R=data[i],G=data[i+1],B=data[i+2];
    const idx=i/4,row=Math.floor(idx/w),col=idx%w;
    let pos=idx;
    if(layout==="matrix_v_serp")
      pos=col%2===0?col*h+row:col*h+(h-1-row);
    else if(layout==="matrix")
      pos=row*w+col;
    else{
      const reverse=(layout==="r2l");
      const dir=(row%2===0?!reverse:reverse);
      pos=dir?(row*w+col):(row*w+(w-1-col));
    }
    const hex=((1<<24)+(R<<16)+(G<<8)+B).toString(16).slice(1);
    pixels.push({idx:pos,color:hex});
  }
  pixels.sort((a,b)=>a.idx-b.idx);

  const settings={brightness:bri,segment,colorFormat,outputMode,device:deviceIP,colorLimit};
  output.value=exportPixels(pixels,settings);
  drawPixelOverlay(pixels,w,h);
}

// -------- Addressing demo ----------
function addressingExample(){
  const m=gId('addressingMode').value;
  let t='';
  if(m==='single')t='["ff0000","00ff00","0000ff"]';
  if(m==='range') t='[10,15,"ffaa00"]';
  if(m==='hybrid')t='["ffaa00",0,5,"00ff00"]';
  alert(`Voorbeeldâ€¯(${m}):\n${t}`);
}

// -------- Segment API ----------
async function getSegments(){
  const ip=gId('deviceIP').value;
  try{
    const res=await fetch(`http://${ip}/json/state`);
    const j=await res.json();
    if(j.seg){console.log("Segments:",j.seg.length,j.seg);}
  }catch(e){console.warn("Segmentâ€¯APIâ€¯fout:",e);}
}

// -------- Visuele overlay ----------
function drawPixelOverlay(pixels,w,h){
  const c=canvas.getContext("2d");
  const W=Math.floor(window.innerWidth/(w*1.5));
  const H=Math.floor(window.innerHeight/(h*1.5));
  const step=Math.max(6,Math.min(W,H));

  canvas.width=w*step;
  canvas.height=h*step;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const pos=y*w+x;
      const p=pixels.find(px=>px.idx===pos);
      const col=p?p.color:"000000";
      c.fillStyle="#"+col;
      c.fillRect(x*step,y*step,step,step);
      c.strokeStyle="#333";c.strokeRect(x*step,y*step,step,step);
      c.fillStyle="#aaa";
      c.font=`${Math.max(6,step/2)}px Arial`;
      c.textAlign="center";c.textBaseline="middle";
      c.fillText(pos,x*step+step/2,y*step+step/2);
    }
  }
}
</script>
</body>
</html>
